Stuff in order of being made:
  orb*.[hc]: an interpretive virtual machine in C
  other *.c: ...and associated utilities
  hohmann.zsh: Yes, I did the math in zsh.  Why not.
  meetgreet.zsh: Likewise.  (Note the variable "fudge" in this and the above.)

  orbit_caml.c, orbit.ml: OCaml bindings for the interpreter &c
  orbutil.ml: attempts at doing physics on my own; never quite worked right

  disas.ml: Now I can disassemble VM programs in ML...
  ncmplr.ml: ...and compile them to C.

The VM-to-C compiler is noteworthy in that it can cause a subset of
the inputs to be vector-valued, thus running several instances of the
machine in parallel.  In particular, values and computations which are
not influenced by the vectorized inputs remain scalar.  Thus, for
example, bin4.obf vectorized on the delta-v input but not the scenario
input will compute the target satellite positions only once, while at
the same time simulating arbitrarily many spaceships.  Aside from
cutting down on reduntant computation, the vectorization should allow
gains from data parallelism (to whatever extent it can be juiced out
of the C compiler; there is likely room for improvement here).

Also, it is possible to have multiple simulations living in the same C
namespace, and have one initialize its state to that of another.
This, for example, could be used for efficiently simulating many
flight plans with a common prefix.

  gridtrace.(ml|c): a failed attempt at finding a path to some satellite
    by casting a parallelogram-grid of delta-v's and, in theory,
    proceeding recursively into grid cells which wind up somewhere
    useful.  (The set of parallelograms is closed under the action of
    the group generated by rotations and scalings, which seems to go
    not entirely badly with orbital mechanics.)  In practice, for
    cells of large enough size to be useful in the initial stages of
    such a search, the grid bends too far out of shape to be useful.
    Oh well.

  scattertrace.(ml|c): oddly like my 2008 strategy; cast a bunch of
    rays at random, and repeatedly focus the dispersion around the
    "best" ray.  This is where I finally got something working enough
    to make the common-prefix stuff happen.  Became piled high with
    dodgy heuristics in the later hours, but I've tried to more or
    less keep compatibility, and record the flags I used (on a new
    OCaml process, which has a deterministic random seed).

